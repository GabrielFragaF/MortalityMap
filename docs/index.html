<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Sea-turtle mortality map</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-vector-grid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>

<style>
:root{
  --bg:#0b1220; --panel:#ffffff; --accent:#0ea5e9;
  --text:#111827; --muted:#6b7280; --shadow:0 8px 24px rgba(0,0,0,.18);
}
html, body { height:100%; margin:0; padding:0; background:var(--bg); }
#map { position:absolute; inset:0; z-index:0; }
#panel {
  position:absolute; top:14px; left:14px; z-index:1001;
  background:var(--panel); padding:14px; border-radius:12px;
  font-family: system-ui, sans-serif;
  font-size:14px; box-shadow:var(--shadow); width:300px; max-height:85vh; overflow:auto;
  border:1px solid #e5e7eb;
}
details { border:1px solid #e5e7eb; border-radius:10px; padding:6px 8px; margin:8px 0; }
summary { cursor:pointer; font-weight:600; color:var(--text); }
select { width:100%; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; }
.filter-multiselect { min-height:38px; }
.btn { width:100%; padding:10px; border-radius:10px; border:none; cursor:pointer; font-weight:700; margin-top:10px; }
.btn-primary { background:var(--accent); color:white; }
.btn-ghost { background:#f3f4f6; }
#legend {
  position:absolute; bottom:18px; right:14px; /* moved to bottom-right */
  z-index:1001; background:var(--panel); padding:10px; border-radius:10px; box-shadow:var(--shadow);
  font-size:13px; border:1px solid #e5e7eb; color:var(--text);
}
.swatch { display:inline-block; width:22px; height:12px; margin-right:6px; border-radius:3px; border:1px solid #9ca3af; }
#toast {
  position:absolute; top:14px; right:14px; z-index:2000;
  display:none; background:#fee2e2; color:#991b1b; padding:8px 10px; border-radius:10px;
  border:1px solid #fecaca; box-shadow:var(--shadow); font-size:13px;
}
</style>
</head>
<body>
<div id="map"></div>
<div id="panel">
  <h1>Mortality map</h1>
  <div>
    <label for="resolution">Resolution</label>
    <select id="resolution">
      <option value="r3">r3</option>
      <option value="r4" selected>r4</option>
      <option value="r5">r5</option>
      <option value="r6">r6</option>
    </select>
  </div>
  <div>
    <label for="counttype">Count Type</label>
    <select id="counttype">
      <option value="weight">Mortality position</option>
      <option value="new_mortality_est_bf_mean">Mortality estimation (mean)</option>
      <option value="new_mortality_est_bf_low">Mortality estimation (low)</option>
      <option value="new_mortality_est_bf_high">Mortality estimation (high)</option>
    </select>
  </div>
  <div id="dynamicFilters"></div>
  <button id="loadBtn" class="btn btn-primary">Reload</button>
  <button id="resetBtn" class="btn btn-ghost">Reset</button>
</div>
<div id="legend"></div>
<div id="toast"></div>

<script>
const map = L.map('map').setView([-24, -45], 5);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution:'&copy; OpenStreetMap contributors', maxZoom: 18
}).addTo(map);

// PMTiles fetch hook
const origFetch = window.fetch.bind(window);
window.fetch = (input, init) => {
  if (typeof input === 'string' && input.startsWith('pmtiles://')) {
    const m = input.match(/^pmtiles:\/\/(.+?)\/(\d+)\/(\d+)\/(\d+)\.pbf$/);
    if (!m) return Promise.reject(new Error('Bad pmtiles URL: ' + input));
    const p = new pmtiles.PMTiles(m[1]);
    return p.getZxy(+m[2], +m[3], +m[4]).then(tile => {
      if (!tile || !tile.data) return new Response(null, {status:204});
      return new Response(tile.data, {status:200});
    });
  }
  return origFetch(input, init);
};

const ramps = {
  all: ['#edf8fb','#b2e2e2','#66c2a4','#238b45','#00441b']
};

let currentLayer = null;
let currentLayerName = null;
let fieldNames = [];

function buildUrl(){
  const res = document.getElementById('resolution').value;
  const counttype = document.getElementById('counttype').value;
  return `hexgrid_${res}_${counttype}.pmtiles`;
}

function updateLegend(ramp){
  const legend = document.getElementById('legend');
  legend.innerHTML = '<b>Hex value</b><br>';
  const breaks = [0,10,50,200,500];
  for (let i=0;i<breaks.length;i++){
    const sw = `<span class="swatch" style="background:${ramp[i]||'#fff'}"></span>`;
    const label = (i<breaks.length-1) ? `${breaks[i]}–${breaks[i+1]}` : `${breaks[i]}+`;
    legend.insertAdjacentHTML('beforeend', `${sw}${label}<br/>`);
  }
}

function toast(msg){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.style.display = 'block';
  setTimeout(()=> t.style.display='none', 4000);
}

function getSelected(fname){
  const el = document.getElementById(`filter-${fname}`);
  return el ? Array.from(el.selectedOptions).map(o=>o.value) : [];
}

function passFilters(props){
  for (const fname of fieldNames){
    const sel = getSelected(fname);
    if (sel.length > 0){
      const v = (props[fname] ?? '').toString();
      if (!sel.includes(v)) return false;
    }
  }
  return true;
}

function featureStyle(properties, ramp){
  const value = properties.sum_val || 0;
  let color = ramp[0];
  if (value > 500) color = ramp[4];
  else if (value > 200) color = ramp[3];
  else if (value > 50) color = ramp[2];
  else if (value > 10) color = ramp[1];
  return { fill: true, fillColor: color, fillOpacity: 0.6, stroke: true, color: color, weight: 0.7 };
}

async function loadMetadata(pmtilesFile){
  const p = new pmtiles.PMTiles(pmtilesFile);
  const meta = await p.getMetadata();
  if (!meta.vector_layers || meta.vector_layers.length === 0){
    toast('No vector layers found in PMTiles');
    return;
  }
  currentLayerName = meta.vector_layers[0].id;
  console.log('Layer names found:', meta.vector_layers.map(l=>l.id));
  fieldNames = Object.keys(meta.vector_layers[0].fields || {});
  buildFilterUI();
  await populateFilterValues(pmtilesFile);
}

function buildFilterUI(){
  const container = document.getElementById('dynamicFilters');
  container.innerHTML = '';
  for (const fname of fieldNames){
    const details = document.createElement('details');
    details.innerHTML = `<summary>${fname}</summary><select id="filter-${fname}" multiple class="filter-multiselect"></select>`;
    container.appendChild(details);
  }
}

async function populateFilterValues(pmtilesFile){
  const p = new pmtiles.PMTiles(pmtilesFile);
  const vals = {};
  for (const fname of fieldNames) vals[fname] = new Set();
  // Sample tiles at z=5 for unique values
  for (let x=0;x<2;x++){
    for (let y=0;y<2;y++){
      const tile = await p.getZxy(5,x,y);
      if (!tile.data) continue;
      const layerData = L.vectorGrid.protobuf;
    }
  }
  // For now: leave options empty — can add unique extraction later
}

function loadLayer(){
  const pmtilesFile = buildUrl();
  const ramp = ramps.all;
  updateLegend(ramp);

  if (currentLayer) currentLayer.remove();

  const urlTemplate = `pmtiles://${pmtilesFile}/{z}/{x}/{y}.pbf`;
  currentLayer = L.vectorGrid.protobuf(urlTemplate, {
    maxNativeZoom: 14,
    maxZoom: 18,
    vectorTileLayerStyles: {
      [currentLayerName]: (properties) => {
        return passFilters(properties) ? featureStyle(properties, ramp) : {fill:false, stroke:false};
      }
    },
    interactive: true
  })
  .on('click', e => {
    const p = e.layer.properties || {};
    const html = Object.entries(p).map(([k,v]) => `<div><b>${k}:</b> ${v}</div>`).join('');
    L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
  })
  .addTo(map);
}

document.getElementById('loadBtn').addEventListener('click', async () => {
  const file = buildUrl();
  await loadMetadata(file);
  loadLayer();
});
document.getElementById('resetBtn').addEventListener('click', () => {
  fieldNames.forEach(fname=>{
    const el = document.getElementById(`filter-${fname}`);
    if (el) Array.from(el.options).forEach(o=>o.selected=false);
  });
  loadLayer();
});

// Initial load
(async ()=>{
  const file = buildUrl();
  await loadMetadata(file);
  loadLayer();
})();
</script>
</body>
</html>
